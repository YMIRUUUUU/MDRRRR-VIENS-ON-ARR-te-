<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Vehicle Dynamics Simulator</title>
    <style>
        :root {
            --bg: #050505;
            --panel: rgba(20, 20, 20, 0.95);
            --accent: #00f2ff;
            --warn: #ffae00;
            --danger: #ff0040;
            --text: #cfcfcf;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Consolas', monospace; color: var(--text); }
        canvas { display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .hud-panel {
            background: var(--panel); border: 1px solid #333; padding: 10px; border-radius: 4px;
            box-shadow: 0 0 15px rgba(0,0,0,0.8); pointer-events: auto;
        }

        /* Top Bar */
        #telemetry-bar { display: flex; gap: 20px; align-self: center; }
        .stat-box { text-align: center; min-width: 80px; }
        .stat-label { font-size: 0.7em; color: #666; text-transform: uppercase; }
        .stat-val { font-size: 1.2em; font-weight: bold; color: white; }

        /* Dashboard (Bottom) */
        #dashboard { align-self: center; display: flex; gap: 30px; align-items: flex-end; }
        
        .tacho-container { position: relative; width: 200px; height: 200px; }
        .gear-indicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 4em; font-weight: 900; color: white; text-shadow: 0 0 10px var(--accent);
        }

        /* G-Meter */
        #g-meter { width: 100px; height: 100px; border: 1px solid #444; position: relative; background: #111; border-radius: 50%; }
        #g-dot { 
            width: 8px; height: 8px; background: var(--danger); border-radius: 50%; position: absolute; 
            top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 5px var(--danger);
        }

        /* Graphics Overlay */
        #graphs { position: absolute; top: 20px; right: 20px; width: 250px; }
        canvas.graph { width: 100%; height: 60px; background: #111; border: 1px solid #333; margin-bottom: 5px; }

        #system-panels {
            position: absolute;
            left: 20px;
            top: 120px;
            display: grid;
            grid-template-columns: repeat(2, minmax(200px, 1fr));
            gap: 12px;
            width: min(520px, 45vw);
        }

        .panel-title {
            font-size: 0.75em;
            text-transform: uppercase;
            color: #777;
            margin-bottom: 6px;
            letter-spacing: 0.08em;
        }

        .system-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .system-row span.value {
            color: white;
            font-weight: 600;
        }

        .system-bar {
            height: 6px;
            border-radius: 3px;
            background: #1a1a1a;
            overflow: hidden;
            margin: 4px 0 8px 0;
        }

        .system-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, #00f2ff, #ffae00);
            width: 0%;
            transition: width 0.1s linear;
        }

        .indicator {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.75em;
            text-transform: uppercase;
        }

        .indicator.ok { background: rgba(0, 242, 255, 0.15); color: var(--accent); }
        .indicator.warn { background: rgba(255, 174, 0, 0.15); color: var(--warn); }
        .indicator.danger { background: rgba(255, 0, 64, 0.15); color: var(--danger); }

        .key-hint { position: absolute; bottom: 20px; left: 20px; font-size: 0.8em; opacity: 0.7; }
        kbd { background: #333; padding: 2px 6px; border-radius: 3px; border-bottom: 2px solid #111; }
    </style>
</head>
<body>

    <!-- Simulation Canvas -->
    <canvas id="simCanvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="telemetry-bar" class="hud-panel">
            <div class="stat-box">
                <div class="stat-label">Vitesse</div>
                <div class="stat-val"><span id="speed">0</span> <small>km/h</small></div>
            </div>
            <div class="stat-box">
                <div class="stat-label">RPM</div>
                <div class="stat-val" id="rpm" style="color: var(--accent)">800</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Charge Pneu AV</div>
                <div class="stat-val" id="load-f">50%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Dérive (Slip)</div>
                <div class="stat-val" id="slip-angle">0°</div>
            </div>
        </div>

        <div id="graphs">
            <div class="stat-label">Couple Moteur (Nm)</div>
            <canvas id="torqueGraph" class="graph" width="250" height="60"></canvas>
            <div class="stat-label">Adhérence Latérale</div>
            <canvas id="gripGraph" class="graph" width="250" height="60"></canvas>
            <div class="stat-label">Température Moteur</div>
            <canvas id="tempGraph" class="graph" width="250" height="60"></canvas>
            <div class="stat-label">Consommation Instantanée</div>
            <canvas id="fuelGraph" class="graph" width="250" height="60"></canvas>
        </div>

        <div id="system-panels">
            <div class="hud-panel">
                <div class="panel-title">Powertrain</div>
                <div class="system-row"><span>Boost</span><span class="value" id="boost">0.0 bar</span></div>
                <div class="system-row"><span>Régime turbo</span><span class="value" id="turbo">0%</span></div>
                <div class="system-row"><span>Temp. embrayage</span><span class="value" id="clutch-temp">75°C</span></div>
                <div class="system-bar"><div class="fill" id="clutch-bar"></div></div>
                <div class="system-row"><span>Couple livré</span><span class="value" id="drive-torque">0 Nm</span></div>
                <div class="system-row"><span>État Moteur</span><span class="indicator ok" id="engine-state">OK</span></div>
            </div>
            <div class="hud-panel">
                <div class="panel-title">Thermique & Fluide</div>
                <div class="system-row"><span>Carburant</span><span class="value" id="fuel">45.0 L</span></div>
                <div class="system-bar"><div class="fill" id="fuel-bar"></div></div>
                <div class="system-row"><span>Temp. eau</span><span class="value" id="coolant">85°C</span></div>
                <div class="system-row"><span>Temp. huile</span><span class="value" id="oil">90°C</span></div>
                <div class="system-row"><span>Pompe</span><span class="indicator ok" id="pump-state">OK</span></div>
            </div>
            <div class="hud-panel">
                <div class="panel-title">Châssis & Pneus</div>
                <div class="system-row"><span>Grip route</span><span class="value" id="road-grip">1.00x</span></div>
                <div class="system-row"><span>Temp. pneus AV</span><span class="value" id="tire-temp-front">75°C</span></div>
                <div class="system-row"><span>Temp. pneus AR</span><span class="value" id="tire-temp-rear">75°C</span></div>
                <div class="system-row"><span>Usure pneus</span><span class="value" id="tire-wear">0%</span></div>
                <div class="system-row"><span>ABS</span><span class="indicator ok" id="abs-state">On</span></div>
                <div class="system-row"><span>TCS</span><span class="indicator ok" id="tcs-state">On</span></div>
            </div>
            <div class="hud-panel">
                <div class="panel-title">Électrique & Sécurité</div>
                <div class="system-row"><span>Batterie</span><span class="value" id="battery">100%</span></div>
                <div class="system-bar"><div class="fill" id="battery-bar"></div></div>
                <div class="system-row"><span>ESC</span><span class="indicator ok" id="esc-state">On</span></div>
                <div class="system-row"><span>Stabilité</span><span class="value" id="stability">100%</span></div>
                <div class="system-row"><span>Dégradation</span><span class="value" id="damage">0%</span></div>
                <div class="system-row"><span>Système</span><span class="indicator ok" id="system-state">Nominal</span></div>
            </div>
        </div>

        <div class="key-hint hud-panel">
            <p><kbd>↑</kbd> Accélérer | <kbd>↓</kbd> Frein/Recul</p>
            <p><kbd>←</kbd> <kbd>→</kbd> Direction</p>
            <p><kbd>ESPACE</kbd> Frein à main</p>
            <p><kbd>D</kbd> Debug Mode (Vecteurs)</p>
        </div>

        <div id="dashboard">
            <div class="hud-panel">
                <div style="text-align:center; margin-bottom:5px; color:#666; font-size:0.8em;">G-FORCE</div>
                <div id="g-meter"><div id="g-dot"></div></div>
            </div>
            
            <div class="tacho-container">
                <canvas id="tachoCanvas" width="200" height="200"></canvas>
                <div class="gear-indicator" id="gear">N</div>
            </div>
        </div>
    </div>

<script>
/**
 * ULTIMATE CAR PHYSICS ENGINE
 * Concept: Rigid Body Dynamics + Simplified Pacejka Tire Model
 * Auteur: Simulation Expert
 */

// --- MATHS UTILITAIRES ---
const Vec2 = {
    new: (x=0, y=0) => ({x, y}),
    add: (v1, v2) => ({x: v1.x + v2.x, y: v1.y + v2.y}),
    sub: (v1, v2) => ({x: v1.x - v2.x, y: v1.y - v2.y}),
    mul: (v, s) => ({x: v.x * s, y: v.y * s}),
    mag: (v) => Math.sqrt(v.x*v.x + v.y*v.y),
    norm: (v) => { const m = Math.sqrt(v.x*v.x + v.y*v.y); return m===0 ? {x:0,y:0} : {x:v.x/m, y:v.y/m}; },
    dot: (v1, v2) => v1.x*v2.x + v1.y*v2.y,
    cross: (v1, v2) => v1.x*v2.y - v1.y*v2.x, // 2D cross product returns scalar (z-component)
    rotate: (v, angle) => {
        const c = Math.cos(angle), s = Math.sin(angle);
        return {x: v.x*c - v.y*s, y: v.x*s + v.y*c};
    },
    project: (v, u) => { // Project v onto u (u must be normalized)
        const d = v.x*u.x + v.y*u.y;
        return {x: u.x*d, y: u.y*d};
    }
};

const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
const lerp = (a, b, t) => a + (b - a) * t;

// --- CONFIGURATION VÉHICULE (SETUP TYPE "SPORT") ---
const CAR = {
    mass: 1400,          // kg
    inertia: 2500,       // kg.m^2 (résistance à la rotation)
    wheelBase: 2.7,      // mètres
    trackWidth: 1.6,     // Largeur voie
    cgToFront: 1.35,     // Centre de gravité vers essieu avant
    cgToRear: 1.35,      // Centre de gravité vers essieu arrière
    cgHeight: 0.5,       // Hauteur centre de gravité (pour transfert masse)
    
    // Moteur & Transmission
    torqueCurve: [ // RPM -> Nm
        {rpm: 0, tq: 200}, {rpm: 1000, tq: 280}, {rpm: 3000, tq: 450}, 
        {rpm: 5500, tq: 520}, {rpm: 7000, tq: 400}, {rpm: 8000, tq: 0}
    ],
    redline: 7200,
    idle: 900,
    gears: [3.8, 2.1, 1.5, 1.1, 0.9, 0.75], // 1 à 6
    reverseRatio: 3.5,
    finalDrive: 3.9,
    differential: 'LSD', // Limited Slip Differential (simulé)

    // Freins
    brakeTorqueMax: 4000,
    handbrakeTorque: 8000,

    // Pneus & Suspensions
    tireGrip: 1.2,      // Coefficient global
    corneringStiffness: 120000, // N/rad (Force latérale par radian de glissement)
    dragCoeff: 0.32,
    frontalArea: 2.2,
    rollingRes: 0.015
};

const SYSTEMS = {
    fuelCapacity: 52, // L
    fuelDensity: 0.74, // kg/L
    baseConsumption: 0.08, // L/min at idle
    boostMax: 1.2, // bar
    turboSpoolRate: 0.8,
    coolantOptimal: 92,
    oilOptimal: 95,
    coolingRate: 0.2,
    tireTempOptimal: 85,
    tireTempRange: 45,
    tireWearRate: 0.00004,
    brakeTempRise: 220,
    brakeTempCool: 0.2,
    batteryCapacity: 60, // Ah
    alternatorOutput: 0.35, // Ah/s
    electricalDrain: 0.08,
    stabilityDecay: 0.3
};

const ENV = {
    ambientTemp: 18,
    trackGrip: 1.0,
    humidity: 0.45,
    wind: Vec2.new(0.3, 0)
};

// --- MOTEUR PHYSIQUE ---

class Tire {
    constructor(isFront) {
        this.isFront = isFront;
        this.slipAngle = 0; // Angle de dérive
        this.slipRatio = 0; // Patinage longitudinal
        this.force = Vec2.new();
        this.load = 0; // Charge verticale (N) en dynamique
        this.angularVel = 0; // Vitesse rotation roue
        this.radius = 0.32; // m
        this.smoke = 0;
    }

    // Modèle Pacejka Simplifié pour la courbe de force latérale
    calculateLateralForce(slipAngle, load, grip=1) {
        // Courbe caractéristique typique d'un pneu
        // Pic à ~6 degrés (0.1 rad), puis chute
        const peakSlip = 0.12; 
        const stiff = CAR.corneringStiffness;
        
        // Saturation de la force (ne peut dépasser coeff de friction * charge)
        const maxForce = load * CAR.tireGrip * grip;
        
        // Formule simplifiée : Force linéaire au début, puis plafonne
        let latForce = -slipAngle * stiff;
        
        // Clamp soft
        if (Math.abs(latForce) > maxForce) {
            latForce = Math.sign(latForce) * maxForce;
            // Glissement excessif -> perte légère d'adhérence (Pneus qui crissent)
            const excess = Math.abs(slipAngle) - peakSlip;
            if (excess > 0) latForce *= Math.max(0.7, 1.0 - excess * 2); 
        }

        return latForce;
    }
}

class CarSimulation {
    constructor() {
        // État cinématique
        this.pos = Vec2.new(0, 0);
        this.vel = Vec2.new(0, 0); // Vitesse monde
        this.heading = 0; // Angle châssis (rad)
        this.yawRate = 0; // Vitesse rotation (rad/s)
        
        // État mécanique
        this.steerAngle = 0;
        this.rpm = CAR.idle;
        this.gear = 0; // 0: N, 1-6: Gears, -1: R
        this.clutch = 0; // 0: Engaged, 1: Disengaged
        this.driveTorque = 0;
        this.turbo = 0;
        this.boost = 0;
        this.clutchTemp = 75;
        this.brakeTemps = [80, 80, 80, 80];
        this.tireTemps = [ENV.ambientTemp + 10, ENV.ambientTemp + 10, ENV.ambientTemp + 12, ENV.ambientTemp + 12];
        this.tireWear = [0, 0, 0, 0];
        this.fuel = SYSTEMS.fuelCapacity;
        this.coolantTemp = SYSTEMS.coolantOptimal;
        this.oilTemp = SYSTEMS.oilOptimal;
        this.battery = 1.0;
        this.alternator = 1.0;
        this.absActive = false;
        this.tcsActive = false;
        this.escActive = false;
        this.stability = 1.0;
        this.damage = 0;
        this.roadGrip = ENV.trackGrip;
        
        // Composants
        this.tires = [
            new Tire(true), new Tire(true),   // FL, FR
            new Tire(false), new Tire(false)  // RL, RR
        ];

        // Télémétrie
        this.gForce = Vec2.new();
        this.debug = false;
        this.skidMarks = []; // Array of polylines
    }

    getEngineTorque(rpm) {
        // Interpolation linéaire de la courbe de couple
        const curve = CAR.torqueCurve;
        if(rpm <= curve[0].rpm) return curve[0].tq;
        if(rpm >= curve[curve.length-1].rpm) return 0;

        for(let i=0; i<curve.length-1; i++) {
            if(rpm >= curve[i].rpm && rpm < curve[i+1].rpm) {
                const t = (rpm - curve[i].rpm) / (curve[i+1].rpm - curve[i].rpm);
                return lerp(curve[i].tq, curve[i+1].tq, t);
            }
        }
        return 0;
    }

    updateTurbo(dt, throttle) {
        const spoolTarget = clamp(throttle * (this.rpm / CAR.redline), 0, 1);
        this.turbo += (spoolTarget - this.turbo) * SYSTEMS.turboSpoolRate * dt;
        this.boost = this.turbo * SYSTEMS.boostMax;
    }

    updateThermals(dt, throttle, brakeForce, slipEnergy) {
        const loadHeat = (throttle * 40) + (this.rpm / CAR.redline) * 30;
        const cooling = SYSTEMS.coolingRate + Math.min(0.8, Vec2.mag(this.vel) / 120);
        const ambient = ENV.ambientTemp;

        this.coolantTemp += (loadHeat - cooling * (this.coolantTemp - ambient)) * dt;
        this.oilTemp += ((loadHeat * 1.1) - cooling * (this.oilTemp - ambient)) * dt;

        this.clutchTemp += ((throttle * 60) - (this.clutchTemp - ambient) * 0.8) * dt;
        this.clutchTemp = clamp(this.clutchTemp, ambient, 180);

        this.brakeTemps = this.brakeTemps.map((temp, i) => {
            const heat = (brakeForce / CAR.brakeTorqueMax) * SYSTEMS.brakeTempRise;
            const cool = SYSTEMS.brakeTempCool + Math.min(0.6, Vec2.mag(this.vel) / 140);
            const tireHeat = Math.abs(slipEnergy[i]) * 0.4;
            return clamp(temp + (heat + tireHeat - cool * (temp - ambient)) * dt, ambient, 900);
        });

        this.tireTemps = this.tireTemps.map((temp, i) => {
            const heat = Math.abs(slipEnergy[i]) * 60;
            const cool = 0.12 + Math.min(0.5, Vec2.mag(this.vel) / 140);
            return clamp(temp + (heat - cool * (temp - ambient)) * dt, ambient, 140);
        });
    }

    updateFuel(dt, throttle) {
        const loadFactor = (this.rpm / CAR.redline) * throttle;
        const flow = SYSTEMS.baseConsumption + loadFactor * 0.9;
        this.fuel = Math.max(0, this.fuel - (flow * dt / 60));
    }

    updateElectrical(dt) {
        const alternatorLoad = clamp(this.rpm / CAR.redline, 0.2, 1.0);
        this.alternator = alternatorLoad;
        const charge = SYSTEMS.alternatorOutput * this.alternator;
        const drain = SYSTEMS.electricalDrain + (this.debug ? 0.1 : 0);
        this.battery = clamp(this.battery + (charge - drain) * dt / SYSTEMS.batteryCapacity, 0, 1);
    }

    updateChassis(dt, slipEnergy) {
        const avgTemp = (this.tireTemps[0] + this.tireTemps[1] + this.tireTemps[2] + this.tireTemps[3]) / 4;
        const tempDelta = Math.abs(avgTemp - SYSTEMS.tireTempOptimal);
        const tempGrip = clamp(1 - (tempDelta / SYSTEMS.tireTempRange), 0.6, 1.05);
        const humidityPenalty = 1 - ENV.humidity * 0.12;
        this.roadGrip = ENV.trackGrip * tempGrip * humidityPenalty;

        this.tireWear = this.tireWear.map((wear, i) => {
            const wearRate = SYSTEMS.tireWearRate * (1 + Math.abs(slipEnergy[i]) * 0.6);
            return clamp(wear + wearRate * dt, 0, 1);
        });

        this.stability = clamp(this.stability + (0.6 - Math.abs(this.yawRate) * 0.08) * dt, 0, 1);
        const instability = clamp((Math.abs(this.yawRate) - 0.6) * 0.6, 0, 0.6);
        this.damage = clamp(this.damage + instability * dt * 0.02, 0, 1);
    }

    update(dt, input) {
        this.updateTurbo(dt, input.throttle);

        // 1. DIRECTION (Volant avec inertie)
        const targetSteer = (input.right - input.left) * 0.6; // Max 35 deg
        const steerSpeed = 5.0 * dt;
        this.steerAngle += clamp(targetSteer - this.steerAngle, -steerSpeed, steerSpeed);

        // 2. VECTEURS LOCAUX
        const cosH = Math.cos(this.heading);
        const sinH = Math.sin(this.heading);
        const forward = {x: sinH, y: -cosH};
        const right = {x: cosH, y: sinH};

        // Vitesse locale (Longitudinale, Latérale)
        const velLocal = {
            x: this.vel.x * right.x + this.vel.y * right.y,
            y: this.vel.x * forward.x + this.vel.y * forward.y 
        }; // x: Latéral, y: Longitudinal

        // 3. TRANSFERT DE MASSE (Simplifié)
        // Accélération longitudinale et latérale (en G)
        const accelLong = (velLocal.y - this.lastVelY) / dt / 9.81 || 0;
        this.lastVelY = velLocal.y; // Memoire pour frame suivante

        // Charge statique par essieu
        const staticWeight = CAR.mass * 9.81;
        const weightFront = staticWeight * (CAR.cgToRear / CAR.wheelBase);
        const weightRear = staticWeight * (CAR.cgToFront / CAR.wheelBase);

        // Transfert dynamique : Ax * h / L * m * g
        const weightTransferLong = (accelLong * CAR.cgHeight / CAR.wheelBase) * staticWeight;
        
        // Charge finale par roue (L/R symétrique pour simplifier le code ici)
        const loadF = (weightFront + weightTransferLong) / 2;
        const loadR = (weightRear - weightTransferLong) / 2;

        this.tires[0].load = loadF; this.tires[1].load = loadF;
        this.tires[2].load = loadR; this.tires[3].load = loadR;

        // 4. FORCES PNEUMATIQUES
        let totalForce = Vec2.new();
        let totalMoment = 0;
        const slipEnergy = [0, 0, 0, 0];

        // Pour chaque roue
        this.tires.forEach((tire, i) => {
            // Position de la roue relative au CG
            const isFront = tire.isFront;
            const wheelOffsetLong = isFront ? CAR.cgToFront : -CAR.cgToRear;
            // On simplifie la largeur de voie pour le moment
            
            // Vitesse de la roue au sol (V_wheel = V_car + Omega x R)
            // Vitesse latérale au niveau de la roue = V_lat_car + YawRate * Dist_Long
            const tireVelLat = velLocal.x + this.yawRate * wheelOffsetLong;
            const tireVelLong = velLocal.y; // Simplification (pas de différentiel de vitesse rotationnelle par voie)

            // Angle de braquage effectif
            const wheelSteer = isFront ? this.steerAngle : 0;
            
            // Calcul Slip Angle (Angle de dérive)
            // Alpha = atan(Vlat / Vlong) - steer
            // Protection div/0
            const absLong = Math.max(1.0, Math.abs(tireVelLong));
            tire.slipAngle = Math.atan2(tireVelLat, absLong) - wheelSteer;

            // Calcul Force Latérale (Pacejka)
            const latForceMag = tire.calculateLateralForce(tire.slipAngle, tire.load, this.roadGrip);
            slipEnergy[i] = Math.abs(tire.slipAngle) * (tire.load / (CAR.mass * 9.81));
            
            // Vecteur Force dans le repère local voiture
            const forceX = Math.cos(wheelSteer) * latForceMag; // Composante latérale pure
            const forceY = Math.sin(wheelSteer) * latForceMag; // Traînée induite par le braquage

            // Accumulation (Force X locale est la force latérale)
            // Attention au repère: Canvas Y est inversé, mais mathématiquement ici on bosse en repère voiture standard
            // Droite = X+, Devant = Y+
            
            // On convertit en repère monde pour la somme
            // Force Latérale agit PERPENDICULAIREMENT à la roue
            const wheelHeading = this.heading + wheelSteer;
            const wheelDir = {x: Math.sin(wheelHeading), y: -Math.cos(wheelHeading)};
            const wheelRight = {x: Math.cos(wheelHeading), y: Math.sin(wheelHeading)};
            
            // Force résultante du pneu (Latérale uniquement ici, propulsion gérée après)
            const tireForceWorld = Vec2.mul(wheelRight, latForceMag); // Force latérale

            // Somme Forces / Moments
            totalForce = Vec2.add(totalForce, tireForceWorld);
            
            // Moment = ForceLat * Distance (Torque autour du CG)
            // Avant : Force * distFront. Arrière : -Force * distRear
            totalMoment += latForceMag * wheelOffsetLong; // Approx simple
            
            // Stockage pour debug/smoke
            tire.force = tireForceWorld;
            tire.smoke = Math.abs(tire.slipAngle) > 0.2 && Math.abs(velLocal.y) > 2 ? Math.min(1, (Math.abs(tire.slipAngle)-0.2)*5) : 0;
        });

        // 5. MOTEUR & TRACTION (Longitudinal)
        // Logique de boîte auto basique
        const wheelRadius = 0.32;
        const wheelRpm = (Math.abs(velLocal.y) * 60) / (2 * Math.PI * wheelRadius);
        
        // Clutch / Gear logic
        if(this.gear === 0 && input.throttle) this.gear = 1;
        if(this.gear === 0 && input.brake && velLocal.y < 1) this.gear = -1;
        
        let driveRatio = 0;
        if (this.gear > 0) driveRatio = CAR.gears[this.gear-1] * CAR.finalDrive;
        else if (this.gear === -1) driveRatio = -CAR.reverseRatio * CAR.finalDrive;

        // RPM Moteur (Lié aux roues si embrayé)
        const targetRpm = Math.abs(wheelRpm * driveRatio);
        this.rpm = Math.max(CAR.idle, targetRpm);
        
        // Auto Shift
        if(this.gear > 0 && this.rpm > 6800 && this.gear < 6) this.gear++;
        if(this.gear > 1 && this.rpm < 2500) this.gear--;

        // Couple aux roues
        const engineTorque = this.getEngineTorque(this.rpm) * (1 + this.boost * 0.35);
        const driveTorque = engineTorque * driveRatio * input.throttle;
        let driveForce = driveTorque / wheelRadius;

        // Freinage
        const brakeT = (input.brake * CAR.brakeTorqueMax) + (input.handbrake ? CAR.handbrakeTorque : 0);
        let brakeForce = Math.min(brakeT / wheelRadius, Math.abs(velLocal.y) * CAR.mass * 10); // Clamp pour pas reculer

        // ABS / TCS Simulation (limiteur par grip)
        const rearLoad = (this.tires[2].load + this.tires[3].load);
        const maxLongForce = rearLoad * CAR.tireGrip * this.roadGrip;
        this.tcsActive = Math.abs(driveForce) > maxLongForce && input.throttle > 0.2;
        if(this.tcsActive) driveForce = Math.sign(driveForce) * maxLongForce;

        const frontLoad = (this.tires[0].load + this.tires[1].load);
        const maxBrakeForce = frontLoad * CAR.tireGrip * this.roadGrip * 1.2;
        this.absActive = Math.abs(brakeForce) > maxBrakeForce && input.brake > 0.2;
        if(this.absActive) brakeForce = Math.sign(brakeForce) * maxBrakeForce;

        // Application Forces Long
        let longForceVal = driveForce;
        if (velLocal.y > 0) longForceVal -= brakeForce;
        else if (velLocal.y < 0) longForceVal += brakeForce;

        // Résistance air & roulement
        const dragForce = 0.5 * CAR.dragCoeff * CAR.frontalArea * 1.225 * velLocal.y * velLocal.y * Math.sign(-velLocal.y);
        const rollForce = -velLocal.y * CAR.rollingRes * CAR.mass * 9.81;

        longForceVal += dragForce + rollForce;
        this.driveTorque = driveTorque;

        // Vecteur Force Longitudinal Monde
        const longForceVec = Vec2.mul(forward, longForceVal);
        totalForce = Vec2.add(totalForce, longForceVec);

        // 6. INTÉGRATION (Newton-Euler)
        const acc = Vec2.mul(totalForce, 1/CAR.mass);
        const alpha = totalMoment / CAR.inertia;

        this.vel = Vec2.add(this.vel, Vec2.mul(acc, dt));
        this.yawRate += alpha * dt;
        
        // Amortissement angulaire (Friction naturelle rotation)
        this.yawRate *= 0.98; 

        this.pos = Vec2.add(this.pos, Vec2.mul(this.vel, dt));
        this.heading += this.yawRate * dt;

        // 7. MAJ TÉLÉMÉTRIE
        // Rotation G-Force dans repère local pour affichage
        const gx = (acc.x * right.x + acc.y * right.y) / 9.81;
        const gy = (acc.x * forward.x + acc.y * forward.y) / 9.81;
        
        // Lissage G-Force
        this.gForce.x += (gx - this.gForce.x) * 0.1;
        this.gForce.y += (gy - this.gForce.y) * 0.1;
        
        // Skidmarks (Trace de pneus)
        if(Math.abs(this.tires[2].slipAngle) > 0.3 || input.handbrake) {
            this.addSkidMark(this.pos, this.heading, 1.0);
        } else {
            this.finishSkidMark();
        }

        this.updateThermals(dt, input.throttle, brakeT, slipEnergy);
        this.updateFuel(dt, input.throttle);
        this.updateElectrical(dt);
        this.updateChassis(dt, slipEnergy);

        const yawStress = Math.abs(this.yawRate) * 0.4;
        this.escActive = yawStress > 0.4 && Vec2.mag(this.vel) > 8;
    }

    addSkidMark(pos, heading, intensity) {
        // Offset pour les roues arrières
        const rearX = pos.x - Math.sin(heading) * CAR.cgToRear;
        const rearY = pos.y + Math.cos(heading) * CAR.cgToRear;
        
        const w = CAR.trackWidth / 2;
        const lX = rearX - Math.cos(heading) * w;
        const lY = rearY - Math.sin(heading) * w;
        const rX = rearX + Math.cos(heading) * w;
        const rY = rearY + Math.sin(heading) * w;

        // Logique de buffer de traces (simplifiée ici pour éviter complexité)
        // Dans une version complète 10k lignes, on utiliserait un QuadTree
        if(this.skidMarks.length === 0 || !this.skidMarks[this.skidMarks.length-1].active) {
            this.skidMarks.push({active: true, ptsL: [], ptsR: [], life: 10.0});
        }
        const current = this.skidMarks[this.skidMarks.length-1];
        current.ptsL.push({x: lX, y: lY});
        current.ptsR.push({x: rX, y: rY});
    }

    finishSkidMark() {
        if(this.skidMarks.length > 0) this.skidMarks[this.skidMarks.length-1].active = false;
    }
}

// --- SYSTÈME RENDU & UI ---

class Game {
    constructor() {
        this.canvas = document.getElementById('simCanvas');
        this.ctx = this.canvas.getContext('2d', {alpha: false});
        
        // Offscreen canvas pour le sol (traces statiques)
        this.bgCanvas = document.createElement('canvas');
        this.bgCtx = this.bgCanvas.getContext('2d');
        
        this.sim = new CarSimulation();
        this.input = { throttle: 0, brake: 0, left: 0, right: 0, handbrake: 0 };
        
        this.camera = { x: 0, y: 0, zoom: 15 };
        this.lastTime = 0;
        
        this.initEvents();
        this.resize();
        requestAnimationFrame(t => this.loop(t));
    }

    initEvents() {
        window.addEventListener('resize', () => this.resize());
        const keys = {};
        const updateInput = () => {
            this.input.throttle = keys['ArrowUp'] ? 1 : 0;
            this.input.brake = keys['ArrowDown'] ? 1 : 0;
            this.input.left = keys['ArrowLeft'] ? 1 : 0;
            this.input.right = keys['ArrowRight'] ? 1 : 0;
            this.input.handbrake = keys[' '] ? 1 : 0;
        };
        window.addEventListener('keydown', e => { keys[e.key] = true; if(e.key==='d') this.sim.debug = !this.sim.debug; updateInput(); });
        window.addEventListener('keyup', e => { keys[e.key] = false; updateInput(); });
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.bgCanvas.width = window.innerWidth;
        this.bgCanvas.height = window.innerHeight;
        // Draw grid on bg
        this.drawStaticWorld();
    }

    drawStaticWorld() {
        const ctx = this.bgCtx;
        ctx.fillStyle = '#0a0a0a'; // Tarmac color
        ctx.fillRect(0,0, ctx.canvas.width, ctx.canvas.height);
        
        // Grille infinie simulée (juste un pattern)
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<ctx.canvas.width; i+=100) { ctx.moveTo(i,0); ctx.lineTo(i, ctx.canvas.height); }
        for(let i=0; i<ctx.canvas.height; i+=100) { ctx.moveTo(0,i); ctx.lineTo(ctx.canvas.width, i); }
        ctx.stroke();

        // Ajout de quelques cônes / obstacles pour référence
        ctx.fillStyle = '#e65100';
        for(let i=0; i<10; i++) {
            const x = Math.random() * ctx.canvas.width;
            const y = Math.random() * ctx.canvas.height;
            ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
        }
    }

    loop(timestamp) {
        const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1);
        this.lastTime = timestamp;

        // Substepping physics for stability (4 steps per frame)
        const steps = 4;
        for(let i=0; i<steps; i++) this.sim.update(dt/steps, this.input);

        this.render();
        this.updateUI();
        requestAnimationFrame(t => this.loop(t));
    }

    render() {
        const ctx = this.ctx;
        const car = this.sim;
        
        // Camera Follow
        this.camera.x += (car.pos.x - this.camera.x) * 0.1;
        this.camera.y += (car.pos.y - this.camera.y) * 0.1;
        
        // Reset
        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle = '#111';
        ctx.fillRect(0,0, this.canvas.width, this.canvas.height);

        // Apply Cam
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const zoom = this.camera.zoom * (1 - Math.min(0.3, Vec2.mag(car.vel)/100)); // Dynamic zoom
        
        ctx.translate(cx, cy);
        ctx.scale(zoom, zoom);
        ctx.translate(-this.camera.x, -this.camera.y);

        // World Grid (Parallax simple ou static)
        this.drawGrid(ctx);

        // Traces (Skidmarks)
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 0.3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        car.skidMarks.forEach(skid => {
            if(skid.ptsL.length < 2) return;
            ctx.beginPath();
            skid.ptsL.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.stroke();
            ctx.beginPath();
            skid.ptsR.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });

        // --- DESSIN VOITURE ---
        ctx.save();
        ctx.translate(car.pos.x, car.pos.y);
        ctx.rotate(car.heading);

        // Ombre portée
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.filter = 'blur(10px)'; // Note: expensive
        ctx.fillRect(-1.1, -2.4, 2.2, 4.8);
        ctx.filter = 'none';

        // Carrosserie (Forme plus complexe)
        // Main Body
        ctx.fillStyle = '#222'; // Chassis bas
        ctx.beginPath(); ctx.roundRect(-0.9, -2.1, 1.8, 4.2, 0.2); ctx.fill();
        
        // Hood & Roof
        const speedShake = Math.random() * (Vec2.mag(car.vel) > 20 ? 0.02 : 0);
        ctx.translate(speedShake, 0);

        ctx.fillStyle = '#37474f'; // Couleur voiture
        ctx.beginPath(); 
        ctx.moveTo(-0.9, -2.0); ctx.lineTo(0.9, -2.0); // Arrière
        ctx.lineTo(0.85, 1.2); ctx.lineTo(-0.85, 1.2); // Capot
        ctx.fill();

        // Cockpit
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.roundRect(-0.7, -1.0, 1.4, 1.8, 0.3); ctx.fill();
        // Vitre
        ctx.fillStyle = 'rgba(100,200,255,0.2)';
        ctx.fillRect(-0.65, -0.2, 1.3, 0.8);

        // Roues
        this.drawWheel(ctx, -0.85, 1.35, car.steerAngle, true); // FL
        this.drawWheel(ctx, 0.85, 1.35, car.steerAngle, true);  // FR
        this.drawWheel(ctx, -0.85, -1.35, 0, false);            // RL
        this.drawWheel(ctx, 0.85, -1.35, 0, false);             // RR

        // Feux
        // Arrière
        ctx.fillStyle = this.input.brake ? '#ff0000' : '#500000';
        ctx.shadowColor = '#ff0000'; ctx.shadowBlur = this.input.brake ? 20 : 0;
        ctx.fillRect(-0.8, -2.15, 0.5, 0.15);
        ctx.fillRect(0.3, -2.15, 0.5, 0.15);
        ctx.shadowBlur = 0;

        // Phares (Cônes de lumière)
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
        ctx.beginPath(); ctx.moveTo(-0.7, 2.0); ctx.lineTo(-4, 15); ctx.lineTo(1, 15); ctx.fill();
        ctx.beginPath(); ctx.moveTo(0.7, 2.0); ctx.lineTo(4, 15); ctx.lineTo(-1, 15); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        
        // Flammes échappement (si haut RPM)
        if(car.rpm > 6500 && Math.random() > 0.7) {
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath(); ctx.arc(0.4, -2.3, 0.1 + Math.random()*0.2, 0, Math.PI*2); ctx.fill();
        }

        // DEBUG VECTORS
        if(car.debug) {
            ctx.strokeStyle = '#0f0'; ctx.lineWidth = 0.05;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, Vec2.mag(car.vel)*0.1); ctx.stroke(); // Vel vector
            // Center of mass
            ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(0,0, 0.1, 0, Math.PI*2); ctx.fill();
        }

        ctx.restore();

        // Fumée Pneus (Global space)
        car.tires.forEach((tire, i) => {
            if(tire.smoke > 0) {
                // Position monde de la roue
                // (Approximation rapide pour rendu)
                const isFront = tire.isFront;
                const offsetL = isFront ? CAR.cgToFront : -CAR.cgToRear;
                const offsetW = (i%2===0 ? -1 : 1) * CAR.trackWidth/2;
                
                const wx = car.pos.x + Math.sin(car.heading)*offsetL + Math.cos(car.heading)*offsetW;
                const wy = car.pos.y - Math.cos(car.heading)*offsetL + Math.sin(car.heading)*offsetW;
                
                this.drawSmoke(ctx, wx, wy, tire.smoke);
            }
        });
    }

    drawWheel(ctx, x, y, angle, front) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.fillStyle = '#111';
        ctx.fillRect(-0.15, -0.35, 0.3, 0.7); // Pneu
        
        // Jante
        ctx.fillStyle = '#444';
        if(Math.abs(this.sim.vel.x) > 1 || Math.abs(this.sim.vel.y) > 1) {
             // Effet flou mouvement
             ctx.fillStyle = '#333';
        }
        ctx.fillRect(-0.1, -0.2, 0.2, 0.4);
        
        // Etrier frein
        if(front) {
            ctx.fillStyle = '#c00';
            ctx.fillRect(-0.12, -0.15, 0.05, 0.3);
        }
        
        ctx.restore();
    }

    drawSmoke(ctx, x, y, amount) {
        ctx.fillStyle = `rgba(200, 200, 200, ${amount * 0.4})`;
        for(let i=0; i<3; i++) {
            const size = 0.5 + Math.random();
            ctx.beginPath();
            ctx.arc(x + (Math.random()-0.5), y + (Math.random()-0.5), size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    drawGrid(ctx) {
        // Dessin procédural d'une grille sol
        const gSize = 10; // mètres
        const range = 50; // mètres autour cam
        
        const startX = Math.floor((this.camera.x - range)/gSize) * gSize;
        const startY = Math.floor((this.camera.y - range)/gSize) * gSize;
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.05;
        ctx.beginPath();
        for(let x = startX; x < this.camera.x + range; x += gSize) {
            ctx.moveTo(x, this.camera.y - range); ctx.lineTo(x, this.camera.y + range);
        }
        for(let y = startY; y < this.camera.y + range; y += gSize) {
            ctx.moveTo(this.camera.x - range, y); ctx.lineTo(this.camera.x + range, y);
        }
        ctx.stroke();
    }

    updateUI() {
        const car = this.sim;
        const vel = Vec2.mag(car.vel) * 3.6;
        
        document.getElementById('speed').textContent = Math.floor(vel);
        document.getElementById('rpm').textContent = Math.floor(car.rpm);
        document.getElementById('gear').textContent = car.gear === 0 ? 'N' : (car.gear === -1 ? 'R' : car.gear);
        
        // G-Meter
        const dot = document.getElementById('g-dot');
        const maxG = 2.0;
        const gx = clamp(car.gForce.x / maxG, -1, 1) * 45;
        const gy = clamp(car.gForce.y / maxG, -1, 1) * 45;
        dot.style.transform = `translate(calc(-50% + ${gx}px), calc(-50% + ${-gy}px))`; // Y inversé en CSS vs Physics

        // Telemetry details
        const frontLoad = (car.tires[0].load + car.tires[1].load) / (CAR.mass * 9.81) * 100;
        document.getElementById('load-f').textContent = frontLoad.toFixed(0) + "%";
        
        const slipDeg = (car.tires[2].slipAngle * 180 / Math.PI).toFixed(1);
        const slipEl = document.getElementById('slip-angle');
        slipEl.textContent = slipDeg + "°";
        slipEl.style.color = Math.abs(slipDeg) > 5 ? 'red' : 'white';

        // Additional System UI
        document.getElementById('boost').textContent = car.boost.toFixed(2) + " bar";
        document.getElementById('turbo').textContent = Math.round(car.turbo * 100) + "%";
        document.getElementById('clutch-temp').textContent = Math.round(car.clutchTemp) + "°C";
        document.getElementById('drive-torque').textContent = Math.round(car.driveTorque) + " Nm";

        const fuelPct = car.fuel / SYSTEMS.fuelCapacity;
        document.getElementById('fuel').textContent = car.fuel.toFixed(1) + " L";
        document.getElementById('fuel-bar').style.width = (fuelPct * 100) + "%";

        document.getElementById('coolant').textContent = Math.round(car.coolantTemp) + "°C";
        document.getElementById('oil').textContent = Math.round(car.oilTemp) + "°C";

        const avgFrontTemp = (car.tireTemps[0] + car.tireTemps[1]) / 2;
        const avgRearTemp = (car.tireTemps[2] + car.tireTemps[3]) / 2;
        document.getElementById('tire-temp-front').textContent = Math.round(avgFrontTemp) + "°C";
        document.getElementById('tire-temp-rear').textContent = Math.round(avgRearTemp) + "°C";
        document.getElementById('tire-wear').textContent = Math.round((car.tireWear.reduce((a,b)=>a+b,0)/4)*100) + "%";
        document.getElementById('road-grip').textContent = car.roadGrip.toFixed(2) + "x";

        const batteryPct = Math.round(car.battery * 100);
        document.getElementById('battery').textContent = batteryPct + "%";
        document.getElementById('battery-bar').style.width = batteryPct + "%";
        document.getElementById('stability').textContent = Math.round(car.stability * 100) + "%";
        document.getElementById('damage').textContent = Math.round(car.damage * 100) + "%";

        this.updateIndicator('engine-state', car.coolantTemp > 115 || car.oilTemp > 130, {ok: 'OK', active: 'ALERTE'});
        this.updateIndicator('pump-state', car.coolantTemp > 120, {ok: 'OK', active: 'SURCH'});
        this.updateIndicator('abs-state', car.absActive, {ok: 'On', active: 'Actif'});
        this.updateIndicator('tcs-state', car.tcsActive, {ok: 'On', active: 'Actif'});
        this.updateIndicator('esc-state', car.escActive, {ok: 'On', active: 'Actif'});
        this.updateIndicator('system-state', car.damage > 0.35 || car.fuel < 5, {ok: 'Nominal', active: 'Critique'});

        document.getElementById('clutch-bar').style.width = clamp((car.clutchTemp - 60) / 120, 0, 1) * 100 + "%";

        // TACHOMETER DRAW
        const tc = document.getElementById('tachoCanvas');
        const tctx = tc.getContext('2d');
        tctx.clearRect(0,0,200,200);
        
        // Arc fond
        tctx.strokeStyle = '#333'; tctx.lineWidth = 15;
        tctx.beginPath(); tctx.arc(100,100, 80, 0.7*Math.PI, 2.3*Math.PI); tctx.stroke();
        
        // Arc RPM
        const pct = (car.rpm / 8000);
        const endAngle = 0.7*Math.PI + (pct * 1.6*Math.PI);
        
        const grad = tctx.createLinearGradient(0,0,200,0);
        grad.addColorStop(0, '#00f2ff'); grad.addColorStop(0.8, '#00f2ff'); grad.addColorStop(1, '#ff0040');
        
        tctx.strokeStyle = grad;
        tctx.beginPath(); tctx.arc(100,100, 80, 0.7*Math.PI, endAngle); tctx.stroke();

        // Graphs (Rolling buffer logic simplifiée pour l'exemple)
        this.drawMiniGraph('torqueGraph', car.getEngineTorque(car.rpm), 600, '#ffae00');
        this.drawMiniGraph('gripGraph', Math.abs(car.tires[2].calculateLateralForce(car.tires[2].slipAngle, 3500, car.roadGrip)), 5000, '#00f2ff');
        this.drawMiniGraph('tempGraph', car.coolantTemp, 140, '#ff0040');
        this.drawMiniGraph('fuelGraph', fuelPct * 100, 100, '#00f2ff');
    }

    drawMiniGraph(id, val, max, color) {
        const c = document.getElementById(id);
        const ctx = c.getContext('2d');
        // Shift image left
        const img = ctx.getImageData(1, 0, c.width-1, c.height);
        ctx.putImageData(img, 0, 0);
        ctx.clearRect(c.width-1, 0, 1, c.height);
        
        // Draw new pixel
        const h = (val / max) * c.height;
        ctx.fillStyle = color;
        ctx.fillRect(c.width-1, c.height - h, 1, h);
    }

    updateIndicator(id, active, labels = {ok: 'OK', active: 'ALERTE'}) {
        const el = document.getElementById(id);
        if(active) {
            el.textContent = labels.active;
            el.classList.remove('ok');
            el.classList.add('danger');
        } else {
            el.textContent = labels.ok;
            el.classList.remove('danger');
            el.classList.add('ok');
        }
    }
}

// Start
window.onload = () => new Game();

</script>
</body>
</html>
